<h3>Infinite List</h3>

<h4>Problem Description</h4>

<p>An infinite list <tt>InfiniteList<T></tt> is a generic list that can store elements of type <tt>T</tt> in order where duplicates are allowed.

<!--
The main differences are:

Lab 3's version of InfiniteList is not always infinite. It can be truncated just like a Stream with limit and takeWhile operations. So methods such as findFirst need to consider the possibility of a finite list, including an empty list.
-->

Unlike the previous lab, intermediate operations of <tt>InfiniteList</tt> should be lazily evaluated.

<!--
We need to be as lazy as possible and only generate the elements (i.e., invoke the Supplier's get() method) when necessary. Once we generate an element, we should not generate it again. So, we cache a copy of the value if it has been generated before. This logic has been written in the head() and tail() method for you.
-->


<h4>The Task</h4>

<p>You are to design your own <tt>InfiniteList</tt> <b>interface</b> with the following requirements below.
As <tt>InfiniteList</tt> is similar to Java's <tt>Stream</tt> in Java, and so, you are <b>not allowed</b> to import packages from <tt>java.util.stream</tt>


<ul>
<li>Create the package <tt>cs2030.mystream</tt> for the <tt>InfiniteList</tt> interface and its implementation class
<li>Use a client class <tt>Main</tt> that imports <tt>cs2030.mystream</tt>
<li>You may want to consider writing an appropriate <tt>toString()</tt> method to keep track of the stream elements
<li>Start the stream pipeline via the following data sources:
<ul>
<li><tt>InfiniteList.generate(Supplier&lt;? extends T&gt; supplier)</tt>
<li><tt>InfiniteList.iterate(T seed, UnaryOperator&lt;T&gt; next)</tt>
</ul>
<!--You need to prevent constructs like: <tt>MyIntStream.of(1,2,3).range(1,3)</tt>
-->
<li>Implement the following <b>terminal</b> operations by following the corresponding specifications of Java's <tt>Stream</tt> API:
<ul>
    <li><tt>long count()</tt>
    <li><tt>void forEach(Consumer&lt;? super T&gt; action)</tt>
    <li><tt>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</tt>
    <li><tt>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</tt>
    <li><tt>Object[] toArray()</tt>
</ul>
<li>Implement the following <b>intermediate</b> operations following he corresponding specifications of Java's <tt>Stream</tt> API:
<ul>
    <li><tt>InfiniteList&lt;T&gt; limit(long maxSize)</tt>
    <li><tt>InfiniteList&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</tt>
    <li><tt><R> InfiniteList&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</tt>
    <li><tt>InfiniteList&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</tt>
</ul>
</ul>

<!--
<p>This task is divided into several levels.
Read through all the levels 
to see how the different levels are related.
<b>You may start from any level.</b>
-->


<!--
<p>Take note of the following assumptions:
<ul>
<li><b>There is no longer an upper bound for the number of customers</b>;
<li>The format of the input is always correct;
<li>Output of a <tt>double</tt> value, say <tt>d</tt>, is to be formatted with <tt>String.format("%.3f", d)</tt>;
<li>Inconsistencies between sample output and actual output involving <tt>-0.000</tt> and <tt>0.000</tt> can be ignored.
-->

<p>Just remember to

<ul>
<li>define a <tt>Main</tt> class with the <tt>main</tt> method to test the functionality.  <b>Do not accept any user input</b>.
<li>compile your program using
<pre>
$ javac -d . *.java
</pre>
<!-- <li>check for output format correctness using the <tt>diff</tt> utility (see specific level for usage details).  Note that only <b>one</b> test case is provided for this;
-->
<li>check for styling errors by invoking <tt>checkstyle</tt>. For example, to check styling for all java files
<pre>
$ checkstyle *.java
</pre>
<li>leave your source files in the main directory; there is no need to create a separate submission directory
<li><b>submit your programs directly to CodeCrunch after your lab
<li>you are encouraged to implement your infinite list in an "effectively immutable" manner. Although the test will not include the re-usablility of infinite lists, having an immutable implementation with no side-effects makes for cleaner code
</ul>

<!--
<b>
<ul>
<li>Deadline: Submit your work to CodeCrunch by Thursday, 15 September, 23:59:59.
</ul>
</b>
-->
